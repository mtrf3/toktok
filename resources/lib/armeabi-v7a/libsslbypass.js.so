function waitForModule(moduleName) {
    return new Promise(resolve => {
        const interval = setInterval(() => {
            const module = Process.findModuleByName(moduleName);
            if (module != null) {
                clearInterval(interval);
                resolve(module);
            }
        }, 0);
    });
}

//Only needed when apk is patched with frida-gadget
spoofSignature() 

function spoofSignature() {
    const originalSignature = "308203873082026fa003020102020432c7a2f7300d06092a864886f70d01010b05003074310b30090603550406130238363111300f060355040813085368616e676861693111300f060355040713085368616e6768616931183016060355040a130f6d75736963616c2e6c7920496e632e3110300e060355040b1307616e64726f6964311330110603550403130a6d75736963616c2e6c79301e170d3135303432383034323731375a170d3430303432313034323731375a3074310b30090603550406130238363111300f060355040813085368616e676861693111300f060355040713085368616e6768616931183016060355040a130f6d75736963616c2e6c7920496e632e3110300e060355040b1307616e64726f6964311330110603550403130a6d75736963616c2e6c7930820122300d06092a864886f70d01010105000382010f003082010a0282010100af12e34c0b031e41e6c99ac3b636d4253aa7584ebc9ae4c59244b02979b80969279f32e6e3dfe01a0d7cb6ed4000e8923dd90d7171a337864f6a64c590db204baab97f013fe8c7defe3cab4c16b24cb6959a3cffb9905723c0a1116d002a9cfd721c1e7a16383d47e27ed4387f8dccba6e44d5741da5cb7a295f8c32b52750c3ed5a56f494ff3d667ca3d59c9c3573bf6856677279b84d45d80c53b3a941911abbe9b15cea636abf9ba63e99b2c9ed7afa48fa2f09681fdd559f4792ecf5a26040018efaf7bd411adb0d52e2a5ad8424a776f543583a7e926c6b0337caa4aefa23f9afe52c9933a1fc6e73bc93db8d4e2ab450c2de90648dd19cd7d09c5652bf0203010001a321301f301d0603551d0e0416041422eb1a0c5448d5ffb28177f145dff7ecf6c1fe21300d06092a864886f70d01010b050003820101002f3427639582fa699602cb08659baaf722cc11ce2e29784130f6b46a5a20637eae4f19106a2433aad8433e1f3e26c2904895666f9f4f461c36f37029c251c7060d9c55453ad390375a34bb7855900238590046d7618e02a2cc91bebf9a1fadb9d220bc92c184723c366b6cbffe938bb0ae802f960f87039d1b7c613ba84282845b97fcecad7468decea3d836f7545369193df04d7406c6a02d0bf70dff36476d3d4b578c229296bf8a357049fe7e577993707d2942c4998b2335c0da96894afbd638a17d863c97f7fde2a87845f87b770200df2e8eb720ad3f4fa9fce89ea29e6cfa2fd0d3c4e7eb10f3b4a29a50dbea3bda6ff378c1d14bc009af66db0a16d2" //This will be set by patch_apk.py
    Java.perform(() => {
        const PackageManager = Java.use("android.app.ApplicationPackageManager");
        const Signature = Java.use("android.content.pm.Signature");
        const ActivityThread = Java.use('android.app.ActivityThread');
        PackageManager.getPackageInfo.overload('java.lang.String', 'int').implementation = function(a, b) {
            const packageInfo = this.getPackageInfo(a, b);
            const context = ActivityThread.currentApplication().getApplicationContext();
            const name = context.getPackageName();
            if (a == name && b == 64) {
                const signature = Signature.$new(originalSignature);
                packageInfo.signatures.value = Java.array('android.content.pm.Signature', [signature]);
            }
            return packageInfo;
        }
    });
}

function hook_certVerify(lib) {
    const arm_offset = "0x1f3804";
    const arm64_offset = "<ARM64_OFFSET>";
    let offset = ptr(0);
    if (Process.arch == "arm" && !isNaN(arm_offset)) {
        offset = ptr(arm_offset);
    } else if (Process.arch == "arm64" && !isNaN(arm64_offset)) {
        offset = ptr(arm64_offset);
    } else {
        logger("[*][-] You need to run gen_script.py first.");
        return;
    }
    const f = lib.base.add(offset);
    try {
        hook_callback(f);
        logger(`[*][+] Hooked certVerify at offset: ${offset}`);
    }catch(e){
        logger(`[*][-] Failed to hook certVerify at offset: ${offset}`);
    }
}

function hook_callback(callback) {
    const f = new NativeFunction(callback, "int", ["pointer", "pointer"]);
    Interceptor.attach(f, {
        onLeave: function(retval) {
            retval.replace(0)
        }
    })
}

function hook_SSL_CTX_set_custom_verify(library) {
    const functionName = "SSL_CTX_set_custom_verify"
    try {
        const f = Module.getExportByName(library.name, functionName);
        const SSL_CTX_set_custom_verify = new NativeFunction(f, 'void', ['pointer', 'int', 'pointer'])

        Interceptor.replace(SSL_CTX_set_custom_verify, new NativeCallback(function(ssl, mode, callback) {
            hook_callback(callback);
            SSL_CTX_set_custom_verify(ssl, mode, callback)
        }, 'void', ['pointer', 'int', 'pointer']));

        logger(`[*][+] Hooked function: ${functionName}`);
    } catch (err) {
        logger(`[*][-] Failed to hook function: ${functionName}`);
        logger(err.toString())
    }
}

function logger(message) {
    console.log(message);
    Java.perform(function() {
        var Log = Java.use("android.util.Log");
        Log.v("TIKTOK_SSL_PINNING_BYPASS", message);
    });
}


logger("[*][*] Waiting for libttboringssl...");
waitForModule("libttboringssl.so").then((lib) => {
    logger(`[*][+] Found libttboringssl at: ${lib.base}`)
    hook_SSL_CTX_set_custom_verify(lib);
});

logger("[*][*] Waiting for libsscronet...");
waitForModule("libsscronet.so").then((lib) => {
    logger(`[*][+] Found libsscronet at: ${lib.base}`)
    hook_certVerify(lib);
});

//Universal Android SSL Pinning Bypass #2
Java.perform(function() {
    try {
        var array_list = Java.use("java.util.ArrayList");
        var ApiClient = Java.use('com.android.org.conscrypt.TrustManagerImpl');
        if (ApiClient.checkTrustedRecursive) {
            logger("[*][+] Hooked checkTrustedRecursive")
            ApiClient.checkTrustedRecursive.implementation = function(a1, a2, a3, a4, a5, a6) {
                var k = array_list.$new();
                return k;
            }
        } else {
            logger("[*][-] checkTrustedRecursive not Found")
        }
    } catch (e) {
        logger("[*][-] Failed to hook checkTrustedRecursive")
    }
});


Java.perform(function() {
    try {
        const x509TrustManager = Java.use("javax.net.ssl.X509TrustManager");
        const sSLContext = Java.use("javax.net.ssl.SSLContext");
        const TrustManager = Java.registerClass({
            implements: [x509TrustManager],
            methods: {
                checkClientTrusted(chain, authType) {
                },
                checkServerTrusted(chain, authType) {
                },
                getAcceptedIssuers() {
                    return [];
                },
            },
            name: "com.leftenter.tiktok",
        });
        const TrustManagers = [TrustManager.$new()];
        const SSLContextInit = sSLContext.init.overload(
            "[Ljavax.net.ssl.KeyManager;", "[Ljavax.net.ssl.TrustManager;", "java.security.SecureRandom");
        SSLContextInit.implementation = function(keyManager, trustManager, secureRandom) {
            SSLContextInit.call(this, keyManager, TrustManagers, secureRandom);
        };
        logger("[*][+] Hooked SSLContextInit")
    } catch (e) {
        logger("[*][-] Failed to hook SSLContextInit")
    }
})
